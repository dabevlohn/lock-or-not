# Сессия вопросов и ответов 23.12.2026

## Двойное разыменование

### Вариант 1

```rust
fn print_first_even(numbers: &[i32]) {
    let Some(n) = numbers.iter().find(|&&x| x % 2 == 0) else {
        println!("Чётных чисел нет");
        return;
    };
    println!("Первое чётное число: {}", n);
}
```

### Вариант 2

```rust
fn print_first_even(numbers: &[i32]) {
    let Some(n) = numbers.iter().find(|x| *x % 2 == 0) else {
        println!("Чётных чисел нет");
        return;
    };
    println!("Первое чётное число: {}", n);
}
```

### Различие: деструктуризация в замыкании

| Аспект               | Вариант 1 (`&&x`)                        | Вариант 2 (`*x`)           |
| :------------------- | :--------------------------------------- | :------------------------- |
| **Closure параметр** | `&&x` — двойная дереференция в сигнатуре | `x` — один параметр `&i32` |
| **Деструктуризация** | Автоматически в параметре замыкания      | Явно через `*x` в теле     |
| **Читаемость**       | Компактнее (деструкт в сигнатуре)        | Явнее (видно `*x` в теле)  |
| **Стиль**            | Функциональный (идиоматичный Rust)       | Императивный               |

### Подробный разбор

#### Вариант 1: `|&&x|`

```rust
// `find()` возвращает Option<&i32>
// Замыкание получает &i32
// &&x означает: дереференцируем сначала в замыкании
numbers.iter().find(|&&x| x % 2 == 0)
                       // ↑↑ две дереференции
                       // & — от iter(), & — от параметра
```

#### Вариант 2: `|x|`

```rust
// `find()` возвращает Option<&i32>
// Замыкание получает &i32
// x — это уже &i32, дереференцируем явно в теле
numbers.iter().find(|x| *x % 2 == 0)
                       // ↑ один параметр &i32
                              // ↑ явная дереференция в теле
```

### Что происходит при выполнении?

Оба варианта **полностью эквивалентны** по производительности:

```
Вариант 1: |&&x| x % 2 == 0
           ↓
           Получает &i32, дереференцирует дважды → i32

Вариант 2: |x| *x % 2 == 0
           ↓
           Получает &i32 как x, явно дереференцирует → i32
```

### Какой выбрать?

#### Вариант 1 — рекомендуется

```rust
|&&x| x % 2 == 0
```

- **Идиоматичен для Rust** — стандартный паттерн в функциональном коде
- **Компактнее** — деструкт в сигнатуре
- **Чётче видна структура** — ясно, что работаем с разыменованным значением

#### Вариант 2 — альтернатива

```rust
|x| *x % 2 == 0
```

- **Более явен** — видно `*` в коде (дереференция)
- **Для тех, кто предпочитает явность** — точно видно, где дереференцируем

### Рекомендация

**Используйте Вариант 1** (`|&&x|`). Это стандартный Rust-идиом, когда работаете с итератором ссылок. Сообщество Rust предпочитает этот стиль.

```rust
// ✅ Правильно и идиоматично
numbers.iter().find(|&&x| x % 2 == 0)

// ✅ Тоже правильно, но менее идиоматично
numbers.iter().find(|x| *x % 2 == 0)
```

## А если ссылка на массив mutable?

**Хороший вопрос!** Если ссылка на массив mutable, ситуация кардинально изменится. Давайте разберём.

### Сценарий: mutable ссылка

```rust
fn print_first_even(numbers: &mut [i32]) {
    let Some(n) = numbers.iter().find(|&&x| x % 2 == 0) else {
        println!("Чётных чисел нет");
        return;
    };
    println!("Первое чётное число: {}", n);
}
```

### Различие между вариантами с mutable ссылкой

#### Вариант 1: `|&&x|`

```rust
let Some(n) = numbers.iter().find(|&&x| x % 2 == 0) else { ... };
```

- ✅ **Работает безопасно**
- `.iter()` возвращает неизменяемый итератор
- Замыкание получает `&i32` и дереференцирует
- Компилятор разрешает

#### Вариант 2: `|x|`

```rust
let Some(n) = numbers.iter().find(|x| *x % 2 == 0) else { ... };
```

- ✅ **Тоже работает безопасно**
- Аналогично варианту 1
- Просто другой синтаксис

### Почему нет проблем?

Ключ в том, что мы используем **`.iter()`, а не `.iter_mut()`**:

```rust
fn print_first_even(numbers: &mut [i32]) {
    // ✅ Правильно — iter() даёт только чтение
    let Some(n) = numbers.iter().find(|&&x| x % 2 == 0) else { ... };

    // ❌ Небезопасно — iter_mut() даёт mutable ссылки
    // let Some(n) = numbers.iter_mut().find(|x| *x % 2 == 0) else { ... };
}
```

### Что произойдёт, если использовать `iter_mut()`?

```rust
fn print_first_even(numbers: &mut [i32]) {
    let Some(n) = numbers.iter_mut().find(|x| {
        // x имеет тип &mut i32
        *x % 2 == 0  // Разыменовываем mutable ссылку
    }) else {
        println!("Нет");
        return;
    };
    println!("Первое чётное: {}", n);  // n: &mut i32
}

fn main() {
    let mut nums = vec![1, 3, 5, 7];
    print_first_even(&mut nums);
    // ✅ Работает, но n — это &mut i32
}
```

### Разница в типах

| Ситуация                      | Замыкание      | Тип `n`    | Безопасность             |
| :---------------------------- | :------------- | :--------- | :----------------------- |
| `&numbers`, `.iter()`         | `&&x` или `*x` | `&i32`     | ✅ Безопасно (read-only) |
| `&mut numbers`, `.iter()`     | `&&x` или `*x` | `&i32`     | ✅ Безопасно (read-only) |
| `&mut numbers`, `.iter_mut()` | `*x` или `x`   | `&mut i32` | ⚠️ Требует осторожности  |

### Опасный пример с `iter_mut()` и многопоточностью

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let nums = Arc::new(Mutex::new(vec![1, 3, 5, 7]));

    let mut handles = vec![];
    for i in 0..3 {
        let nums_clone = Arc::clone(&nums);
        handles.push(thread::spawn(move || {
            let mut guard = nums_clone.lock().unwrap();

            // ❌ Если попытаться mutable найти без Mutex — паника!
            // guard.iter_mut().find(|x| {
            //     *x = i;  // Опасно — write в общий массив
            //     *x % 2 == 0
            // })

            // ✅ Правильно — только чтение
            guard.iter().find(|&&x| x % 2 == 0);
        }));
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```

### Итог для `&mut [i32]`

```rust
fn print_first_even(numbers: &mut [i32]) {
    // Оба безопасны — используют .iter() (read-only)
    let Some(n) = numbers.iter().find(|&&x| x % 2 == 0) else { ... };
    // или
    let Some(n) = numbers.iter().find(|x| *x % 2 == 0) else { ... };
}
```

**`&mut` сигнатура не влияет на безопасность**, если вы используете `.iter()`. Опасность появляется только если:

1. Вы используете `.iter_mut()`
2. Несколько потоков пытаются одновременно писать в массив
3. Нет `Mutex` для синхронизации

## Приведение типов через `as`

### Основной принцип

- Rust хранит целые числа в двоичной форме с использованием дополнения до двух (two's complement) для знаковых типов. Это означает, что отрицательные числа не запоминаются как “минус”; запоминается их битовая последовательность.
- Приведение через as не выполняет арифметическое преобразование по модулю или округление. Оно просто переинтерпретирует те же биты как значения другого типа или размерности.

### Почему отрицательное число становится очень большим положительным

- Рассмотрим пример: -180i64 приводим к u64.
- В i64 значение -180 записано в двоичном виде как дополняющий код: 2^64 - 180.
- Когда эти же биты интерпретируются как беззнаковое число (u64), они представляют число 2^64 - 180, то есть 18446744073709551436.
- Проще говоря: битовый паттерн не изменяется; меняется толкование того, что означают эти биты.

### Примеры

- i32 -> u32
  - Возьмем -1 в i32: двоичное представление — все единицы (0xFFFFFFFF).
  - Приведение к u32 трактует те же биты как беззнаковые: 0xFFFFFFFF, который равен 4294967295.
- i16 -> u8
  - Пусть -2 в i16: двоичный паттерн 0xFFFE.
  - Приведение к u8 берет младшие 8 бит: 0xFE, что равно 254.
  - Этим объясняется, почему причина переинтерпретации может приводить к неожиданно большим или другим значениям: старшие биты теряются при усечении до меньшего размера.

### Тонкости и риски

- Так же работает любая привязка через as между знаковыми и беззнаковыми типами одного и того же представления или между разными представлениями, когда размер отличается.
- При этом стоит помнить, что существуют предотвращающие переполнения или проверки через check_cast (или явные безопасные конверсии), которые могут сигнализировать об опасных преобразованиях.
- Если нужно сохранить числовую величину в рамках нового типа, лучший способ — явное вычисление и проверка, например через методы как try_from или проверочные условия, чтобы поймать переполнение.

### Дополнительные примеры

- i64 -> u64: -1 становится 18446744073709551615
- i8 -> u8: -1 становится 255
- i8 -> u16: -1 становится 65535 (помните, младшие биты сохраняются, старшие становятся 0)

## Сборка проектов в workspace

### На примере репозитория

## Варианты использования mod.rs

### На примере репозитория
